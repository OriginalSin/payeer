# payeer

Изменение баланса не зависит от истории операций!

Оно зависит только от lastAsk (это самая нижня цена в верхнем стакане) и lastBid (самая верхняя цена в нижнем стакане).

Действительно, если в истории операций есть какая-то верхняя строка, то она отражает последнюю завершенную операцию.

После этой операции цены продажи и покупки на будущее уже определяются значениями lastAsk, lastBid,
и никак не зависят от завершенной операции и ее цены.

Баланс меняется только из-за наличия крипты в портфеле и только по двум причинам:

1) в момент покупки мы теряем на разнице курсов покупки и продажи

2) изменение курса продажи (lastBid нижнего стакана)

Новый алгоритм

В нем три пункта.

1. Оптимальный момент покупки крипты

Операция покупки приводит к следующему изменению баланса 
(мы считаем для простоты, что покупка происходит мгновенно, т.е. количество покупаемой крипты не больше, чем в строке lastAsk)

balance = lastBalance * Bid / lastAsk,

где Bid - это верхняя цена в нижнем стакане на момент вычисления баланса
(например, в момент покупки Bid = lastBid)

Момент покупки надо выбирать так, чтобы баланс был максимален.

Пусть у нас есть возможность выбрать два момент покупки и две цены покупки lastAsk1, lastAsk2

Если выберем первый момент, balance = lastBalance * Bid / lastAsk1

Если выберем второй момент, balance = lastBalance * Bid / lastAsk2

Очевидно, оценка баланса в любой момент в будущем будет больше во втором варианте, если lastAsk2 < lastAsk1

Поэтому делаем предсказание nextBid и nextAsk (используя линейную интерполяцию или сплайны, или еще как-то).

Покупку делаем, если

1) nextAsk > Ask
(т.е. ожидает рост цены покупки - в нижней строчке верхнего стакана,
если мы купим не сейчас, а на следующем шаге изменения стаканов, будет хуже )

2) nextBid > Bid
(т.е. ожидается рост цены продажи - в верхней строчки нижнего стакана)

В противном случае (т.е. если не ожидается рост цены покупки, или цены продажи, или обеих) - покупку не делаем.

Сразу после покупки выставляем ордер StopLoss (см. ниже).

2. Момент продажи крипты ввиду достижения нужного дохода (TakeProfit)

Устанавливаем для себя критерий, когда мы фиксируем прибыль. Например, 3%. 

Выставляем ордер на продажу 100% крипты по цене LastBid * 1.03

Пока цена Bid в стакане меньше, ордер ждет выполнения. При достижении этой цены ордер автоматически срабатывает.

3. Момент продажи валюты ввиду достижения уровня убытка (StopLoss)

Устанавливаем для себя критерий, когда мы останавливаем убыток. Например, -2%. 

Выставляем ордер на покупку 100% крипты по цене lastBid * 0.98

Пока цена Bid в стакане больше, ордер ждет выполнения. При достижении этой цены ордер автоматически срабатывает.

4. Общая логика работы алгоритма:

Покупаем крипту (если она еще не куплена) в нужный момент (когда Bid и Ask растут одновременно)

После покупки сразу выставляем StopLoss.

Отслеживаем изменение цены Bid в нижнем стакане.

Если Bid вырос и установлен StopLoss, отменяем его и ставим TakeProfit.

Если Bid вырос и не установлен StopLoss, продолжаем держать TakeProfit (если его нет, устанавливаем его).

Если Bid упал и Bid > lastBid * 0.99, ничего не делаем (т.е. держим ордер TakeProfit)

Если Bid упал и lastBid * 0.98 < Bid < lastBid * 0.99, устанавливаем StopLoss

Если Bid упал и Bid < lastBid * 0.98, устанавливаем StopLoss по текущей цене Bid (т.е. немедленно продаем крипту)

.............................

23.01.2021 Составление истории сделок на бирже

На сайте в каждый момент времени доступны 100 последних сделок (время+цена+колчество+сумма+вид), упорядоченных по убыванию времени:
0: "14:17+32900.00+0.00303951+100+buy"
1: "14:16+32800.00+0.00083045+27.24+buy"
2: "14:16+32800.00+0.00304878+100+buy"
3: "14:15+32800.00+0.00304878+100+buy"
4: "14:15+32799.99+0.000164+5.37+sell"
5: "14:15+32800.00+0.00018262+5.99+buy"
6: "14:14+32800.00+0.00015197+4.98+buy"
7: "14:13+32799.99+0.00015556+5.1+sell"
8: "14:13+32800.00+0.00084146+27.6+sell"
9: "14:13+32800.00+0.00027439+9+sell"
10: "14:13+32800.00+0.00192709+63.21+sell"
11: "14:12+32900.00+0.00023647+7.78+buy"
12: "14:11+32800.00+0.00063388+20.79+buy"
13: "14:11+32799.99+0.00042909+14.08+buy"
14: "14:09+32799.99+0.00015018+4.92+buy"
15: "14:09+32800.00+0.0001067+3.5+buy"
...
89: "13:29+32900.00+0.000142+4.67+sell"
90: "13:28+32900.00+0.001+32.9+sell"
91: "13:26+32990.00+0.00054379+17.94+buy"
92: "13:25+32899.00+0.00032625+10.73+sell"
93: "13:25+32899.00+0.00063036+20.73+sell"
94: "13:25+32899.00+0.0002+6.57+sell"
95: "13:23+32999.99+0.0001+3.29+buy"
96: "14:17+32800.00+0.00188761+61.91+sell"
97: "14:17+32777.00+0.00915275+300+sell"
98: "14:17+32778.00+0.12913506+4232.79+sell"
99: "14:17+32779.01+0.0038128+124.98+sell"

Опрашивая следующий раз эти данные, мы получаем более актуальный снимок 100 последних сделок.
Задача: составить историю сделок, т.е. "сшить" моментальные снимки в один единый список (добавляя новые значения сверху).
Для этого конец моментального снимка надо совместить с началом истории.
Учесть при этом, что в списке не исключены повторения строк (когда последовательные сделки одинаковы и имеют совпадающее время).
В едином списке должно правильно отражаться количество идущих подряд одинаковых строк.

В общем случае восстановить историю по моментальным снимкам однозначно не получится.

Пример 1:
Пусть история состоит, скажем, из 200 одинаковых значений. Новый снимок также содержит только одинаковые значения.
В этом случае непонятно, какая часть значений моментального снимка новая.

Пример 2:
Если моментальыне снимки производятся не так часто, возможны "провалы" в истории - когда значения моментального списка не пересекаются с историей.

Поэтому предполагаем, что снимки происходят не слишком редко (по сравнению с частотой сделок).
Из всех возможных склеиваний снимка и истории берем склеивание наибольшей длины (выбираем вариант с наименьшим изменением истории).

снимок.slice(0,100].join()==история.slice(0,100).join() => новая история равна старой
или
снимок.slice(1,100).join()==история.slice(0,99).join() => новая история равна снимок.slice(0,1)+история
или
снимок.slice(2,100].join()==история.slice(0,98).join() => новая история равна снимок.slice(0,2)+история
или
..
снимок.slice(99,100).join()==история.slice(0,1).join() => новая история равна снимок.slice(0,99)+история
или новая история равна снимок.slice(0,100)+история

